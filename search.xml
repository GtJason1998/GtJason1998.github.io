<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>信号矩阵理论学习笔记</title>
    <url>/2020/03/09/%E4%BF%A1%E5%8F%B7%E7%9F%A9%E9%98%B5%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="信号矩阵理论学习笔记"><a href="#信号矩阵理论学习笔记" class="headerlink" title="信号矩阵理论学习笔记"></a>信号矩阵理论学习笔记</h1><a id="more"></a>
<h2 id="线性代数知识补充"><a href="#线性代数知识补充" class="headerlink" title="线性代数知识补充"></a>线性代数知识补充</h2><ul>
<li>$rank(AB) = min\{rank(A),rank(B)\}$</li>
<li>$(A^{-1})^T=(A^T)^{-1}$</li>
<li>$Tr(AB) = Tr(BA)$</li>
<li>$(AB)^T = B^TA^T$ </li>
<li>$(AB)^* = A^*B^*$<blockquote>
<p>转置前后矩阵位置交换<br>共轭前后矩阵位置不变</p>
</blockquote>
</li>
<li>矩阵可逆 $&lt;=&gt;$ 矩阵行列式不等于0 $&lt;=&gt;$ 矩阵满秩</li>
<li>矩阵特征值的个数等于其阶数，非零特征值的个数等于矩阵的秩 <br><br>$Q^{-1}RQ=\Lambda$，因为$Q$矩阵可逆，所以$Q$矩阵满秩，所以<br>$rank(Q^{-1}RQ) = min\{rank(Q^{-1},rank(R),rank(Q)\}= rank(R)= rank(\Lambda)$<br><br> 根据等式后两项，有矩阵的秩等于非零特征值的个数</li>
</ul>
<h2 id="输入信号相关矩阵"><a href="#输入信号相关矩阵" class="headerlink" title="输入信号相关矩阵"></a>输入信号相关矩阵</h2><ul>
<li>$R = E[X^*X^T]$ 其中$R$为$Hermite$阵，即$R^H = R$</li>
<li><p>$\omega^H R \omega$ &nbsp;$&lt;=&gt;$ &nbsp;输出信号功率 <br><br>因为自适应组合器信号输出(见课本公式(2.3))</p>
<script type="math/tex; mode=display">y(t)=q_n^TX = X^Tq_n</script><p>&emsp;&emsp;所以输出功率</p>
<script type="math/tex; mode=display">E[|y(t)|^2]=E[y^*(t)y(t)]=E[q_n^HX^*X^Tq_n] = q_n^HE[X^*X^T]q_n=q_n^HRq_n</script><p>&emsp;&emsp;其中$\omega$为信号线性组合器模型中的权向量，$R$为信号相关矩阵 <br><br>&emsp;&emsp;因为输出功率恒大于等于0且为实数，同时由于$Rq_n=\lambda_nq_n$，两边同乘$q_n^H$有</p>
<script type="math/tex; mode=display">
q_n^HRq_n=\lambda_nq_n^Hq_n</script><p>&emsp;&emsp;由于$q_n^Hq_n$为非零特征向量的内积，故$q_n^Hq_n$恒大于0，所以$\lambda_n$均为大于或等于0的正实数，即$\lambda_n \geq 0$，所以信号相关矩阵$R$为正定或半正定矩阵，详见<a href="https://baike.baidu.com/item/正定矩阵/11030459?fr=aladdin" target="_blank" rel="noopener">正定矩阵充要条件第4条</a></p>
</li>
<li><p>$R$可分解为(证明见课件)</p>
<script type="math/tex; mode=display">R=Q\Lambda Q^H \tag{1}</script><p>将等式(1)拆解开，还可表示为</p>
<script type="math/tex; mode=display">
R = \sum\lambda_iq_iq_i^H</script><p>&emsp;其中$\lambda_i$为信号相关矩阵的特征值，$q_i$为特征值$\lambda_i$对应的特征向量 <br><br>&emsp;因为<u><strong>特征向量矩阵$Q$内的所有特征向量是相互正交并各自归一化的，且不同特征值对应的特征向量相互正交</strong></u>(证明过程见课件)，即$Q$矩阵与$Q$矩阵自己的内积中非对角元素均为0，所以有$Q^HQ = I$,$I$为单位矩阵,所以有</p>
<script type="math/tex; mode=display">Q^{-1} = Q^H \tag{2}</script><p>&emsp;等式(2)和等式(1)联合，有</p>
<script type="math/tex; mode=display">R = Q\Lambda Q^H = Q\Lambda Q^{-1} \tag{3}</script></li>
<li>矩阵$R$的特征值之和为输入信号的功率 <br><br>因为$Tr(\Lambda) = Tr(R) = E[x_0^*x_0] + E[x_1^*x_1] + \cdots + E[x_L^*x_L]$(证明见课件)，其中等号最后一项即为各通道的输入功率之和</li>
</ul>
<h2 id="信号子空间和噪声子空间"><a href="#信号子空间和噪声子空间" class="headerlink" title="信号子空间和噪声子空间"></a>信号子空间和噪声子空间</h2><ul>
<li><p>信号子空间$U_s$与噪声子空间$U_n$正交 <br></p>
<script type="math/tex; mode=display">U_s \overset{\Delta}{=} span[q_0,q_1,\cdots,q_{r-1}]</script><script type="math/tex; mode=display">U_n \overset{\Delta}{=} span[q_r,q_{r+1},\cdots,q_{L}]</script><script type="math/tex; mode=display">
\begin{bmatrix} K_1U_s & 0 \\ 0 & 0 \end{bmatrix} \cdot \begin{bmatrix} 0 & 0 \\ 0 & K_2U_n \end{bmatrix} = \begin{bmatrix} 0 & 0 \\ 0 & 0 \end{bmatrix}</script></li>
<li><p>阵列导向向量是由信号子空间张成的基向量组成的</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Adaptive Signal Processing</category>
      </categories>
  </entry>
  <entry>
    <title>FMCW雷达距离多普勒(RDM)处理方法中距离分辨率和速度分辨率的推导</title>
    <url>/2020/02/26/FMCW%E9%9B%B7%E8%BE%BE%E8%B7%9D%E7%A6%BB%E5%A4%9A%E6%99%AE%E5%8B%92-RDM-%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E4%B8%AD%E8%B7%9D%E7%A6%BB%E5%88%86%E8%BE%A8%E7%8E%87%E5%92%8C%E9%80%9F%E5%BA%A6%E5%88%86%E8%BE%A8%E7%8E%87%E7%9A%84%E6%8E%A8%E5%AF%BC/</url>
    <content><![CDATA[<h1 id="1-距离多普勒-Range-Dopple-Matrix-处理方法"><a href="#1-距离多普勒-Range-Dopple-Matrix-处理方法" class="headerlink" title="1. 距离多普勒(Range-Dopple Matrix)处理方法"></a>1. 距离多普勒(Range-Dopple Matrix)处理方法</h1><p>&emsp;&emsp;众所周知，距离多普勒处理方法(Range-Dopple Matrix，简称RDM)是FMCW雷达进行多目标信息提取的有效手段，通过对雷达发送的多个周期的Chirp序列以及回波信息进行快时间维度和慢时间维度的处理，即可得到距离多普勒热力图，进而可以提取多目标的距离和速度信息。<br><a id="more"></a><br><img src="https://img-blog.csdnimg.cn/20200212132950250.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="FMCW Multi-Chirp"><br>&emsp;&emsp;在FMCW的差拍信号中，我们知道，差拍信号的频率为</p>
<script type="math/tex; mode=display">f_{movingBeat} = f_{staticBeat} \pm f_d = \frac{2f_cR}{Ct_c} \pm \frac{2fv}{C} \tag 1</script><p>&emsp;&emsp;其中$f_{movingBeat}$和$f_{staticBeat}$分别为目标运动和静止状态下差拍信号的频率，$f_d$为多普勒频率，$f_c$为扫频带宽，$R$为目标距离，$C$为光速，$t_c$为扫频周期，$f$为Chirp信号中心频率，$v$为目标速度。</p>
<h2 id="1-1-快时间维度处理-Range-FFT"><a href="#1-1-快时间维度处理-Range-FFT" class="headerlink" title="1.1. 快时间维度处理(Range-FFT)"></a>1.1. 快时间维度处理(Range-FFT)</h2><p>&emsp;&emsp;快时间维度即单个周期的Chirp序列扫频周期时间很短，短到几乎可以将多普勒频率带来的影响忽略不计($t_c$↓，公式(1)中$f_{staticBeat}$项占了主要的位置)，认为此时通过RDM热力图提取到的动目标在距离维度上的动目标差频$f_{movingBeat}$与静目标差频$f_{staticBeat}$近似相等，即</p>
<script type="math/tex; mode=display">f_{movingBeat} \approx f_{staticBeat} =  \frac{2f_cR}{Ct_c} \tag 2</script><p>&emsp;&emsp;那么通过快时间维度的每一帧数据，提取频谱峰值对应的横坐标频率，即可对目标的距离进行求解；即</p>
<script type="math/tex; mode=display">R = \frac{Ct_c}{2f_c}\cdot f_{staticBeat} \tag 3</script><p>&emsp;&emsp;快时间维处理示意图如下<br><img src="https://img-blog.csdnimg.cn/20200212133123832.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="Range-FFT"></p>
<h2 id="1-2-慢时间维度处理-Doppler-FFT"><a href="#1-2-慢时间维度处理-Doppler-FFT" class="headerlink" title="1.2. 慢时间维度处理(Doppler-FFT)"></a>1.2. 慢时间维度处理(Doppler-FFT)</h2><p>&emsp;&emsp;因为我们知道，在快时间维的处理中，认为速度带来的影响忽略不计，通过对多个Chirp序列进行多帧数据的堆积，此时在第二个维度上(即慢时间维度上，多帧数据对应的同一距离单元上)速度带来的频率影响就不可忽略，此时慢时间维度上求得的频率即为多普勒频率，即</p>
<script type="math/tex; mode=display">f_d = \frac{2fv}{C} \tag 4</script><p>&emsp;&emsp;所以有</p>
<script type="math/tex; mode=display">v = \frac{f_dC}{2f} \tag 5</script><p>&emsp;&emsp;慢时间维处理示意图如下<br><img src="https://img-blog.csdnimg.cn/20200212134519777.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="Doppler-FFT"><br>&emsp;&emsp;慢时间维度的处理是经过多个Chirp序列积累后对<strong>同一距离单元</strong>进行FFT的结果，故称为慢时间维度，</p>
<blockquote>
<p>为什么是同一距离单元？<br>因为Range-FFT中同一个横坐标对应相同的$f_{movingBeat}$，快时间维度下$f_{movingBeat}$约等于$f_{staticBeat}$，由公式(2)和公式(3)可知，对应同一距离单元</p>
</blockquote>
<p>&emsp;&emsp;快时间维度和慢时间维度处理总览<br><img src="https://img-blog.csdnimg.cn/20200212123652486.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="两个维度总览"><br>&emsp;&emsp;经过处理后可得到如下的距离多普勒热力图(Range-Dopple Heat Map)<br><img src="https://img-blog.csdnimg.cn/2020021213115734.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="Range-Dopple Heat Map"></p>
<h1 id="2-RDM中距离分辨率和速度分辨率推导方法"><a href="#2-RDM中距离分辨率和速度分辨率推导方法" class="headerlink" title="2. RDM中距离分辨率和速度分辨率推导方法"></a>2. RDM中距离分辨率和速度分辨率推导方法</h1><p>&emsp;&emsp;网上关于RDM方法中距离分辨率和速度分辨率推导的资料实在太少，几乎都是两个长得不太好看公式直接糊你脸上，我的感受就是<del>老人、地铁、看手机.jpg</del>(此处省略表情包)，于是决定记录下推导过程，正所谓难者不会，会者不难。<br>&emsp;&emsp;首先回顾下数字信号处理中第K个采样点的频率$f_k$与采样频率$f_s$间的关系，我们知道，第K个采样点的角频率服从如下关系</p>
<script type="math/tex; mode=display">\omega_k = \frac{k}{N_s}\cdot2\pi = \Omega\cdot T_s = 2 \pi f_k\cdot \frac{1}{f_s}</script><p>&emsp;&emsp;其中$N_s$为采样点数，$\Omega$为模拟角频率，$T_s$为采样频率，我们取出等式中的第二项和第四项，有</p>
<script type="math/tex; mode=display">\frac{k}{N_s}\cdot2\pi =2 \pi f_k\cdot \frac{1}{f_s}</script><p>&emsp;&emsp;可得第K个采样点的频率$f_k$与采样频率$f_s$间的关系为</p>
<script type="math/tex; mode=display">f_k = k\cdot \frac{f_s}{N_s} \tag 6</script><p>&emsp;&emsp;到此就可以正式展开距离分辨率和速度分辨率的推导方法了，上一部分我们说到快时间维度的Range-FFT和慢时间维度的Doppler-FFT，有两个结论性的公式</p>
<script type="math/tex; mode=display">f_{movingBeat} \approx f_{staticBeat} =  \frac{2f_cR}{Ct_c} \tag 7</script><script type="math/tex; mode=display">f_d = \frac{2fv}{C}  \tag 8</script><p>&emsp;&emsp;假设上一部分中距离多普勒热力图中，$n_1$为Range-FFT(快时间维度)中目标对应的坐标序列号，$n_2$为Doppler-FFT(慢时间维度)中同一目标对应的坐标序列号，则依照公式(6)可得</p>
<script type="math/tex; mode=display">f_{movingBeat} = \frac{n_1}{N_s} \cdot f_s \tag 9</script><script type="math/tex; mode=display">f_d = \frac{n_2}{N_{Chirp}} \cdot \frac{1}{t_c} \tag {10}</script><p>&emsp;&emsp;其中$N_{Chirp}$为慢时间维度处理中Chirp序列的积累个数；公式(9)类比公式(6)，比较好理解，公式(10)也是类比公式(6)，只不过此时<strong>在慢时间维度上</strong>采样总数是积累的Chirp序列的总数，采样频率是每一个Chirp序列扫频周期的倒数，即$\frac{1}{t_c}$<br>&emsp;&emsp;由此以来，分别联立公式(7)和公式(9)，联立公式(8)和公式(10)，可得</p>
<script type="math/tex; mode=display">\frac{2f_cR}{Ct_c} = \frac{n_1}{N_s} \cdot f_s</script><script type="math/tex; mode=display">\frac{2fv}{C} = \frac{n_2}{N_{Chirp}} \cdot \frac{1}{t_c}</script><p>&emsp;&emsp;可解得</p>
<script type="math/tex; mode=display">R = \frac{C}{2f_C}\cdot t_c\cdot \frac{n_1}{N_s}\cdot f_s \tag{11}</script><script type="math/tex; mode=display">v = \frac{C}{2f} \cdot \frac{n_2}{N_{Chirp}}\cdot \frac{1}{t_c}\tag{12}</script><p>&emsp;&emsp;因为 </p>
<script type="math/tex; mode=display">t_c = N_s\cdot T_s = \frac{N_s}{f_s} \tag{13}</script><script type="math/tex; mode=display">t_{seq} = N_{Chirp}\cdot t_c\tag{14}</script><p>&emsp;&emsp;将(13)代入(11)，将(14)代入(12)，可得</p>
<script type="math/tex; mode=display">R = \frac{C}{2f_c} \cdot n_1</script><script type="math/tex; mode=display">v = \frac{C}{2ft_{seq}} \cdot n_2</script><p>&emsp;&emsp;此时，就得到了距离分辨率和速度分辨率，分别为</p>
<script type="math/tex; mode=display">R_{res} = \frac{C}{2f_c}</script><script type="math/tex; mode=display">v_{res} = \frac{C}{2fN_{Chirp}t_c} = \frac{C}{2ft_{seq}}</script><h1 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3. 参考资料"></a>3. 参考资料</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/31047473" target="_blank" rel="noopener">Automotive radar 信号处理 第2课 速度估计</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/77500626" target="_blank" rel="noopener">Radar测距及测速原理(2)——快速Chirp序列方法推导及实际应用</a></li>
<li><a href="https://mp.weixin.qq.com/s/3pmABLMsirzEXcIn3a2_Pw" target="_blank" rel="noopener">2D CFAR的原理，其实没那么的神奇</a></li>
</ul>
]]></content>
      <categories>
        <category>Radar</category>
      </categories>
  </entry>
  <entry>
    <title>树莓派踩坑日记——初始配置</title>
    <url>/2020/02/26/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0%E2%80%94%E2%80%94%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><strong><em>无显示器无键盘、仅有一根网线时初步配置树莓派</em></strong><br><a id="more"></a></p>
<h1 id="1-Raspbian系统安装"><a href="#1-Raspbian系统安装" class="headerlink" title="1. Raspbian系统安装"></a>1. Raspbian系统安装</h1><p>使用读卡器烧录Raspbian镜像，可以烧录已经开启SSH的镜像源，方便直接连接，未开启SSH的话，在boot分区建立一个名为ssh的文件(无后缀)，即可</p>
<h1 id="2-通过网线连接树莓派"><a href="#2-通过网线连接树莓派" class="headerlink" title="2. 通过网线连接树莓派"></a>2. 通过网线连接树莓派</h1><p>在控制面版——网络和Internet——网络连接界面设置网络共享，然后网线连接树莓派，进入<code>cmd终端</code>，输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arp -a</span><br></pre></td></tr></table></figure>
<p>查看分配的ip地址，使用命令连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh pi@ip_address</span><br></pre></td></tr></table></figure>
<h1 id="3-初始配置"><a href="#3-初始配置" class="headerlink" title="3. 初始配置"></a>3. 初始配置</h1><h2 id="3-1-wifi配置"><a href="#3-1-wifi配置" class="headerlink" title="3.1. wifi配置"></a>3.1. wifi配置</h2><p>打开<code>wifi</code>，修改wifi配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/wpa_supplicant/wpa_supplicant.conf</span><br></pre></td></tr></table></figure>
<p>改成如下格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line">country=CN</span><br><span class="line">network=&#123;</span><br><span class="line">        ssid=<span class="string">"MERCURY_930E"</span></span><br><span class="line">        psk=<span class="string">"606606606"</span></span><br><span class="line">        key_mgmt=WPA-PSK</span><br><span class="line">        priority=4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最好将手机热点设置为最高优先级，通过设置优先级，保证你的树莓派可以连上wifi，之后只需通过起到路由功能的设备即可查看树莓派ip，同理通过ssh连接。<br>还有就是，按照网上方法修改<code>/etc/dhcpcd.conf</code>路径下的文件，设置静态ip，可以保证树莓派可以访问，但存在无法访问网络的问题，可能是DNS未配置好所致。</p>
<h2 id="3-2-raspi-config"><a href="#3-2-raspi-config" class="headerlink" title="3.2. raspi-config"></a>3.2. raspi-config</h2><h3 id="3-2-1-更改密码"><a href="#3-2-1-更改密码" class="headerlink" title="3.2.1. 更改密码"></a>3.2.1. 更改密码</h3><p>选择第一项，按提示更改密码</p>
<h3 id="3-2-2-拓展文件系统"><a href="#3-2-2-拓展文件系统" class="headerlink" title="3.2.2. 拓展文件系统"></a>3.2.2. 拓展文件系统</h3><p>保证你的整张SD卡可以被你的Raspbian系统访问，通过如下命令可以查看区别</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>
<h3 id="3-2-3-更改分辨率"><a href="#3-2-3-更改分辨率" class="headerlink" title="3.2.3. 更改分辨率"></a>3.2.3. 更改分辨率</h3><p>一般来说，需要根据你的显示器更改分辨率，视情况而定</p>
<h2 id="3-3-更改镜像源"><a href="#3-3-更改镜像源" class="headerlink" title="3.3. 更改镜像源"></a>3.3. 更改镜像源</h2><p>修改<code>/etc/apt/sources.list</code>和<code>/etc/apt/sources.list.d/raspi.list</code>文件，更改方法网上搜索很多，更改镜像源，然后执行更新指令即可完成初步配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade</span><br></pre></td></tr></table></figure>
<h1 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h1><p>千万不要在操作文件系统/使用树莓派GPIO口时断电，可能会造成文件系统损坏，导致之后无法正常进入系统，也就导致不能通过wifi或者网线连接树莓派</p>
]]></content>
      <categories>
        <category>RaspberryPi</category>
      </categories>
  </entry>
  <entry>
    <title>Linux中的echo命令做文本写入及文本追加</title>
    <url>/2020/02/26/Linux%E4%B8%AD%E7%9A%84echo%E5%91%BD%E4%BB%A4%E5%81%9A%E6%96%87%E6%9C%AC%E5%86%99%E5%85%A5%E5%8F%8A%E6%96%87%E6%9C%AC%E8%BF%BD%E5%8A%A0/</url>
    <content><![CDATA[<p>Linux中的<code>echo</code>命令，使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> text &gt; text.txt</span><br></pre></td></tr></table></figure>
<p>可以将text文本重定向至text.txt中<br><a id="more"></a></p>
<p><img src="https://img-blog.csdnimg.cn/20191023171525303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="echo文本重定向"><br>但若是想要作一个文本追加，则需要使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> text &gt;&gt; text.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191023171857597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="echo文本追加"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Matplotlib绘图中文无法显示</title>
    <url>/2020/02/26/Matplotlib%E7%BB%98%E5%9B%BE%E4%B8%AD%E6%96%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><a id="more"></a>
<p>在使用Matplotlib绘图过程中，中文无法显示，如下</p>
<p><img src="https://img-blog.csdnimg.cn/20191023165735108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="中文无法显示"><br>只需要在程序中添加以下代码即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> mpl</span><br><span class="line">mpl.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'SimHei'</span>] <span class="comment"># 指定默认字体</span></span><br><span class="line">mpl.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span>  <span class="comment"># 解决保存图像是负号'-'显示为方块的问题</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191023170033174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="中文正常显示"><br><strong>但若是使用的Linux系统</strong>,比如我使用的是deepin，则需要先去网上下载SimHei.ttf的字体文件，拷贝至以下目录下(user处应为对应用户名，具体情况具体分析)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/home/user/.<span class="built_in">local</span>/lib/python3.6/site-packages/matplotlib/mpl-data/fonts/ttf</span><br></pre></td></tr></table></figure>
<p>然后再删除掉以下这个名为matplotlib的目录即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/home/user/.cache/matplotlib</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Python中的引用与浅拷贝</title>
    <url>/2020/02/26/Python%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h1 id="1-导语"><a href="#1-导语" class="headerlink" title="1. 导语"></a>1. 导语</h1><p>挺绕的知识点，自己边看别人的博客边整理自己遇到的问题，磕磕绊绊写下这篇博客<br><a id="more"></a></p>
<h1 id="2-浅谈变量、对象及引用间的关系"><a href="#2-浅谈变量、对象及引用间的关系" class="headerlink" title="2. 浅谈变量、对象及引用间的关系"></a>2. 浅谈变量、对象及引用间的关系</h1><p><img src="https://img-blog.csdnimg.cn/20191023110947950.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="变量、对象及引用间的关系"></p>
<ul>
<li>变量 ：变量可以看作是一个标签，它无类型，建立后存入系统变量表</li>
<li>引用 ：引用可以看作是一个特殊的”指针”，它存放着对象的地址</li>
<li>对象 ：对象是计算机分配的一块实际的内存，里边存放着相应的值<h1 id="3-引用-reference"><a href="#3-引用-reference" class="headerlink" title="3. 引用(reference)"></a>3. 引用(reference)</h1>在Python中，<strong>赋值语句</strong>，总是在 <strong>建立对象的引用</strong>(建立指针) 或是 <strong>修改变量的引用</strong>(修改指针)，通过引用可以查看相应的值在内存中的存放地址，Python中，通过内置函数id()来查看对象的存放地址，如<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">id(list1)	<span class="comment">#该语句可以查看list1列表在进程空间中的存放地址</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-1-可变对象与不可变对象的引用问题"><a href="#3-1-可变对象与不可变对象的引用问题" class="headerlink" title="3.1. 可变对象与不可变对象的引用问题"></a>3.1. 可变对象与不可变对象的引用问题</h2><p>Python中，对象可分为可变对象和不可变对象，首先讨论什么是可变对象，什么是不可变对象</p>
<ul>
<li>可变对象 ：如list、set、dict<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>]	<span class="comment">#可变对象，赋值语句在此处是在建立对象的引用</span></span><br><span class="line">list2 = list1			</span><br><span class="line">print(id(list1),id(list2))</span><br><span class="line">list1[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">print(list2)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20191023160728248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="可变对象"><br>list1与list2指向同一块内存，通过修改list1，可以发现list2也受到了影响</p>
<ul>
<li>不可变对象 ：如str、number、tuple</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">'123'</span>	<span class="comment">#不可变对象，赋值语句在此处是在建立对象的引用</span></span><br><span class="line">print(id(str1))</span><br><span class="line">str1 = <span class="string">'012'</span>	<span class="comment">#创建新对象，并修改该变量的引用</span></span><br><span class="line">print(id(str1))</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191023161006193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="不可变对象"><br>此处的赋值语句，是在先创建了一个新的str对象的基础上，在修改变量str1的引用</p>
<h1 id="4-浅拷贝-shallow-copy"><a href="#4-浅拷贝-shallow-copy" class="headerlink" title="4. 浅拷贝(shallow copy)"></a>4. 浅拷贝(shallow copy)</h1><p>在使用NumPy的ndarray对象时，可使用该对象的copy()方法实现浅拷贝(shallow copy)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">array = np.arange(<span class="number">5</span>)</span><br><span class="line">array_illusion = array</span><br><span class="line">array_copy = array.copy()</span><br><span class="line">print(id(array),id(array_illusion),id(array_copy))</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191023162826950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="浅拷贝"><br>根据输出的内存地址可以得知，未使用copy()方法的赋值语句，只是给第1行建立的ndarray对象又建立了一个新的引用，并贴上array_illusion的“标签”，而使用copy()方法则是真正的建立了一个新的ndarray对象</p>
<h1 id="5-后记"><a href="#5-后记" class="headerlink" title="5. 后记"></a>5. 后记</h1><p>最近在完成学校的数值计算作业的时候，将Matlab的程序转为了Python的程序来实现，由于里边每一次的迭代都需要重新赋值，自己在编写的时候又忽略了Python赋值语句本质上是在操控引用，不像Matlab那样只需要空间预分配就行，进而导致怎么都算不出正确结果，查阅资料补了补知识，在Python赋值语句的后边加上了.copy()，便得到了正确的结果，所以决定写下这篇博客，作为一个学习笔记。本来还想一起把深拷贝的内容也写了，但考虑到自己掌握的也不是太好，同时也不在这篇文章的讨论范围内，就索性等有时间再写了&gt;_&lt;</p>
<h2 id="5-1-参考文章"><a href="#5-1-参考文章" class="headerlink" title="5.1. 参考文章"></a>5.1. 参考文章</h2><p><a href="https://blog.csdn.net/qq_40911298/article/details/100060756" target="_blank" rel="noopener">Python 赋值引用、浅拷贝、深拷贝详细解析</a><br><a href="https://my.oschina.net/leejun2005/blog/145911" target="_blank" rel="noopener">python基础（5）：深入理解 python 中的赋值、引用、拷贝、作用域</a><br><a href="https://blog.csdn.net/Invokar/article/details/89138684" target="_blank" rel="noopener">Python变量引用浅析</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Linux中的Bash操作符&amp;,&amp;&amp;,|,||及部分基本指令</title>
    <url>/2020/02/26/Linux%E4%B8%AD%E7%9A%84Bash%E6%93%8D%E4%BD%9C%E7%AC%A6-%E5%8F%8A%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="1-操作符-amp-amp-与"><a href="#1-操作符-amp-amp-与" class="headerlink" title="1. 操作符&amp;&amp;与||"></a>1. 操作符&amp;&amp;与||</h1><ul>
<li>&amp;&amp;表示当前一条命令执行成功时,执行后一条命令</li>
<li>||表示当前一条命令执行失败时,才执行后一条命令<a id="more"></a>
当前目录下的子目录如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191003000600742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70" alt="操作符&amp;&amp;与||]"><br>使用如下命令区分&amp;&amp;与||的不同之处<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> Documents/ &amp;&amp; <span class="built_in">echo</span> success    <span class="comment">#success</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> Doc/ &amp;&amp; <span class="built_in">echo</span> fail             <span class="comment">#fail</span></span><br><span class="line"><span class="built_in">cd</span> Doc/ || <span class="built_in">echo</span> success          <span class="comment">#success</span></span><br><span class="line"><span class="built_in">cd</span> Documents/ || <span class="built_in">echo</span> fail       <span class="comment">#fail</span></span><br></pre></td></tr></table></figure>
执行结果如下：<br><img src="https://img-blog.csdnimg.cn/20191003001614414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70" alt="操作符&amp;&amp;与||"><br>根据ls命令返回的结果可知，当前目录下存在名为Documents的子目录，不存在名为Doc的子目录，所以第二条指令可以进入Documents子目录并输出success；接着使用命令返回上一层目录，而当前目录下不存在名为Doc的子目录，所以第三条指令不会输出fail；||的解读方法以此类推。</li>
</ul>
<h1 id="2-操作符-amp-与"><a href="#2-操作符-amp-与" class="headerlink" title="2. 操作符&amp;与|"></a>2. 操作符&amp;与|</h1><ul>
<li>&amp;表示将任务置于后台运行</li>
<li>|表示将前一条命令的输出，用作后一条命令的输入<br>为了更好的解读操作符&amp;与|，首先编写了一个如下的C语言程序</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"usage: CPU &lt;string&gt;\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *str = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usleep(<span class="number">1000000</span>);   <span class="comment">//delay 1S</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序在执行时，每隔1秒输出一次执行时的命令行参数；编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc cpu.c -o cpu.out</span><br></pre></td></tr></table></figure>
<p>通过如下命令来后台执行多个任务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./cpu.out A &amp; ./cpu.out B &amp; ./cpu.out C &amp;</span><br></pre></td></tr></table></figure>
<p>执行上述命令后，通过如下指令来查看运行情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -A | grep cpu.out</span><br></pre></td></tr></table></figure>
<p>上述指令中包含了管道符|，前一条指令的输出做后一条指令的输入，通过ps -A查看进程状态，输出信息做后一条字符串搜索指令grep的输入，进而实现查询cpu.out进程的运行情况，结果如下<br><img src="https://img-blog.csdnimg.cn/20191003004439729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70" alt="操作符&amp;与|"><br><img src="https://img-blog.csdnimg.cn/20191003004453373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70" alt="操作符&amp;与|"><br>可以看见已经查询到了后台运行的三个cpu.out进程，接着使用kill  PID指令关闭这三个进程<br><img src="https://img-blog.csdnimg.cn/20191003004658967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70" alt="操作符&amp;与|"><br><img src="https://img-blog.csdnimg.cn/2019100300471039.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70" alt="操作符&amp;与|"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/02/26/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><a id="more"></a>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h3 id="Clean-the-local-static-files"><a href="#Clean-the-local-static-files" class="headerlink" title="Clean the local static files"></a>Clean the local static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/commands" target="_blank" rel="noopener">Commands</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
</search>
