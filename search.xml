<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基本自适应算法学习笔记</title>
    <url>/2020/04/14/%E5%9F%BA%E6%9C%AC%E8%87%AA%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>&nbsp;<br><a id="more"></a></p>
<ul>
<li><p>最小均方算法(LMS)：亮点在于将最速下降法中的微商法梯度估计换为了瞬时梯度估计，计算量大幅下降，即：</p>
<blockquote>
<p>LMS = 最速下降法 + 瞬时梯度估计</p>
</blockquote>
</li>
<li><p>序列回归算法(SER)：</p>
<blockquote>
<p>SER = 牛顿法 + 瞬时梯度估计 + 迭代求逆</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Adaptive Signal Processing</category>
      </categories>
  </entry>
  <entry>
    <title>如何读论文</title>
    <url>/2020/04/09/%E5%A6%82%E4%BD%95%E8%AF%BB%E8%AE%BA%E6%96%87/</url>
    <content><![CDATA[<h1 id="Bilibili大佬up分享论文阅读方法"><a href="#Bilibili大佬up分享论文阅读方法" class="headerlink" title="Bilibili大佬up分享论文阅读方法"></a>Bilibili大佬up分享论文阅读方法</h1><h3 id="1-nbsp-入门算法岗，准备读研，如何高效阅读机器学习顶会论文？"><a href="#1-nbsp-入门算法岗，准备读研，如何高效阅读机器学习顶会论文？" class="headerlink" title="1 &nbsp;入门算法岗，准备读研，如何高效阅读机器学习顶会论文？"></a>1 &nbsp;<a href="https://www.bilibili.com/video/BV1Z541147b1" target="_blank" rel="noopener">入门算法岗，准备读研，如何高效阅读机器学习顶会论文？</a></h3><a id="more"></a>
<ul>
<li><p>读论文 $\ne$ 读教材</p>
<ul>
<li>教材花费了作者大量的时间去打磨</li>
<li>大多数的论文不值得逐字逐句的去精心研读</li>
<li>不是所有的论文都值得去复现，顶会中的best paper或做了oral的论文更值得复现</li>
</ul>
</li>
<li><p>综述性论文</p>
<ul>
<li>对某一领域用到的方法或者工具进行总结</li>
</ul>
</li>
<li><p>确定需不需要精读一篇文章</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">文章标题</th>
<th style="text-align:center">摘要(用自己的一句话描述，说清楚该文用了什么方法解决了什么问题)</th>
<th style="text-align:center">是否需要精读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">标题1</td>
<td style="text-align:center">文章1摘要(用自己的一句话描述)</td>
<td style="text-align:center">是或否</td>
</tr>
<tr>
<td style="text-align:center">$\vdots$</td>
<td style="text-align:center">$\vdots$</td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center">标题n</td>
<td style="text-align:center">文章n摘要(用自己的一句话描述)</td>
<td style="text-align:center">是或否</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>对于需要精读的文章，<del>得先把自己假想成一个杠精</del>，带着挑错的方式、<strong>带着提问的态度</strong>去精读，精读顺序：</p>
<ul>
<li><code>Abstract</code></li>
<li><code>Introducion</code></li>
<li><code>Conclusion</code></li>
<li><code>Algorithm\Model\System Design</code></li>
<li><code>Experiment</code></li>
<li><code>Related Work</code><blockquote>
<p>中间任何一步若发现不是所需解决的问题，或正在读的是一篇<del>辣鸡文章</del>，也可就此停止阅读</p>
</blockquote>
</li>
</ul>
</li>
<li><p>精读<code>Algorithm\Model\System Design</code>部分需有主次之分，<strong>每段的第1句是重点</strong>，需要仔细阅读，第1句一般是对某一段的一个整体概括；第1句阅读后如果比较了解，暂且可以先跳过该段后面的细节部分</p>
</li>
<li>精读<code>Algorithm\Model\System Design</code>部分后，如果仍然对本篇论文感兴趣，这个时候才可以开始<code>Experiment</code>部分的阅读</li>
<li>精读<code>Experiment</code>部分，这个时候才决定该篇论文是否需要复现，因为复现论文需要耗费大量的时间精力</li>
<li><code>Related Work</code>部分也很重要，该部分强调该文与相关工作间的关系，该领域以前用到了什么样的方法$\ldots \dots$，需要精读</li>
</ul>
<blockquote>
<ul>
<li>读完后需进行反思<ul>
<li>在阅读摘要部分时自己提出的问题，在读完整篇文章后有没有得到很好的解答<ul>
<li>Q1:……………………?<ul>
<li>A1:………………….</li>
</ul>
</li>
<li>Q2:……………………?<ul>
<li>A2:…………………. </li>
</ul>
</li>
</ul>
</li>
<li>Related Work(挑选文中<code>Related Work</code>中重要的部分记录即可)<ul>
<li>XXXXXX</li>
<li>XXXXXX</li>
<li>XXXXXX</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><strong>单纯的摘抄文中的内容没有太大的意义，重要的是思考，转化成自己的语言来描述</strong></li>
</ul>
<h3 id="2-nbsp-论文英语看着头疼？数学公式太复杂？论文复现无从下手？"><a href="#2-nbsp-论文英语看着头疼？数学公式太复杂？论文复现无从下手？" class="headerlink" title="2 &nbsp;论文英语看着头疼？数学公式太复杂？论文复现无从下手？"></a>2 &nbsp;<a href="https://www.bilibili.com/video/BV14i4y187X4" target="_blank" rel="noopener">论文英语看着头疼？数学公式太复杂？论文复现无从下手？</a></h3><ul>
<li>注重每一部分的第一段，每一段的第一句</li>
<li>英文论文的阅读主要<strong>注重专业词汇</strong>意思的理解，在不影响句意理解的情况下，不知道的通用词汇只需把握其整体色彩(褒义、贬义$\ldots \ldots$等)，没有必要拿出词典来查这个词，因为你正在做的事情是读论文，不是学英语</li>
<li>论文中看不懂的复杂数学公式，可考虑将公式一层一层拆解开来看，哪一层看不懂就去查相应的知识</li>
<li>在<strong>已经看懂</strong>了论文的基础上，才应该考虑复现的问题</li>
<li>英文论文中不了解的专业词汇，先查阅$Wikipedia$+其他相应的资料，弄懂后再继续阅读</li>
</ul>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>矩阵对角化笔记</title>
    <url>/2020/04/05/%E7%9F%A9%E9%98%B5%E5%AF%B9%E8%A7%92%E5%8C%96%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>&nbsp;<br><a id="more"></a></p>
<h2 id="线性代数知识补充"><a href="#线性代数知识补充" class="headerlink" title="线性代数知识补充"></a>线性代数知识补充</h2><ul>
<li>$Laplace$法则:<script type="math/tex; mode=display">
|AB| = |A|\cdot|B|</script></li>
<li><p><a href="https://blog.csdn.net/keneyr/article/details/102836659" target="_blank" rel="noopener">矩阵初等变换与行列式间的关系</a></p>
</li>
<li><p><strong>正定矩阵</strong>$A$的转置$A^{T}$等于它本身，即</p>
<script type="math/tex; mode=display">
A^{T} = A</script><p>正定矩阵定义：特征值都是正数的实对称矩阵</p>
</li>
</ul>
<h2 id="矩阵对角化笔记"><a href="#矩阵对角化笔记" class="headerlink" title="矩阵对角化笔记"></a>矩阵对角化笔记</h2><ul>
<li>关于欧几里得空间的证明，需证明内积$(x,y)满足$<ol>
<li>交换律 $(x,y) = (y,x)$</li>
<li>分配律 $(x,y+z) = (x,y) + (x,z)$</li>
<li>齐次律 $(kx,y) = k(x,y)$</li>
<li>非负性 $(x,x) \geq 0$，当且仅当$x = 0$时，$(x,x) = 0$</li>
</ol>
</li>
<li><a href="https://blog.csdn.net/qq_45011547/article/details/91126133" target="_blank" rel="noopener">关于度量矩阵</a></li>
<li>$Gram-Schmidt$正交化需先证明给定的向量$x_1,x_2,\cdots,x_n$为一组线性无关的向量，然后才可进行正交化；若需求解的是标准正交基，先正交化后，再进行单位化即可</li>
</ul>
]]></content>
      <categories>
        <category>Matrix Theory</category>
      </categories>
  </entry>
  <entry>
    <title>权向量求解学习笔记</title>
    <url>/2020/04/01/%E6%9D%83%E5%90%91%E9%87%8F%E6%B1%82%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="最速下降法"><a href="#最速下降法" class="headerlink" title="最速下降法"></a>最速下降法</h2><ul>
<li>最速下降法梯度搜索式<a id="more"></a>
<script type="math/tex; mode=display">
W_{k+1} = W_{k} + \mu(-\nabla_k)</script></li>
<li><p><strong>单实权</strong>情况下，即仅有一个输入通道，权向量$W$为一个标量，输入信号相关矩阵$R$维度为$1\times 1$，此时$R$表示输入信号的功率，用$\lambda$表示，故代价函数$\varepsilon(V)$中的偏差功率部分为</p>
<script type="math/tex; mode=display">
V_k^HRV_k = \lambda(W_k - W_{opt})^2 \tag{1}</script><p>故 </p>
<script type="math/tex; mode=display">
\frac{\mathrm{d}\varepsilon}{\mathrm{d}\omega} = 2\lambda(W_k - W_{opt}) = 2\lambda V_k \tag{2}</script></li>
<li><p><strong>高维自适应系统</strong>下(权向量$W$为$N \times 1$的向量)，类比(2)，梯度算子</p>
<script type="math/tex; mode=display">
\nabla_k = 2RV_k = 2R[W_k - W_{opt}]  = 2R[W_k - R^{-1}P^{*}] = 2[RW_k - P^{*}] \tag{3}</script><p>在最小均方误差准则(MMSE)下，$W_{opt} = R^{-1}P^{*}$</p>
</li>
<li>高维自适应系统下，需对权偏差向量$V$进行解耦合处理，即令<script type="math/tex; mode=display">
V_k = QV_k^{'}</script>其中$Q$为信号相关矩阵$R$的特征向量矩阵，$V^{‘}$为经过解耦合处理后的权偏差向量，权偏差向量迭代公式由<script type="math/tex; mode=display">
V_{k+1} = \underbrace{[I - 2\mu R]}_{Non-Diagonal}V_k = \underbrace{[I - 2\mu R]^{k}}_{Non-Diagonal}V_0 \tag{4}</script>变化为<script type="math/tex; mode=display">
V_{k+1}^{'} = \underbrace{[I - 2\mu \Lambda]}_{Diagonal}V_k^{'} = \underbrace{[I - 2\mu \Lambda]^{k}}_{Diagonal}V_0^{'} \tag{5}</script>式中，$V_0$、$V_0^{‘}$为权偏差向量迭代初始值，$R$为输入信号相关矩阵，$\Lambda$为输入信号相关矩阵$R$的特征值矩阵($\Lambda$为一对角阵)，此时标记部分由非对角阵变为了对角阵，好处是两次迭代间某一通道第$k+1$次权偏差值只和本通道第$k$次权偏差值有关，和其他通道第$k$次的权偏差值无关，即实现了所谓的解耦合，即<script type="math/tex; mode=display">
v_{k+1,l}^{'} = (1 - 2\mu \lambda_l)^kv_{0,l}^{'} \tag{6}</script>其中，$k$为迭代次数，$l$表示信号的通道编号<h2 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h2></li>
<li>参考(3)前两项，有$\nabla_k = 2R[W_k - W_{opt}]$，故可得<script type="math/tex; mode=display">
W_{opt} = W_k - \frac{1}{2}R^{-1}\nabla_k \tag{7}</script></li>
<li>牛顿法梯度搜索式<script type="math/tex; mode=display">
W_{k+1} = W_{k} - \mu R^{-1}\nabla_k \tag{8}</script>按(7)来说，牛顿法应该是一步收敛的，但由于实际应用的过程中，无法得到$R^{-1}$和$\nabla_k$的真值，得到的仅为估计值$\hat{R}^{-1}$和$\hat{\nabla}_k$，故需进行迭代求解稳定权值</li>
</ul>
<h1 id="微商法梯度估计"><a href="#微商法梯度估计" class="headerlink" title="微商法梯度估计"></a>微商法梯度估计</h1><ul>
<li>稳态性能分析：指$\nabla_k \approx 0$</li>
<li>最速下降法和牛顿法进行权向量迭代的过程中，需要对梯度算子$\nabla_k$进行估计，故梯度估计值表示为$\hat{\nabla}_k$<script type="math/tex; mode=display">
\hat{\nabla}_k = \nabla_k + N_k</script>其中$N_k$为梯度估计噪声</li>
<li><del>微商法梯度估计里各种公式推导看得我好懵。。。</del> </li>
</ul>
]]></content>
      <categories>
        <category>Adaptive Signal Processing</category>
      </categories>
  </entry>
  <entry>
    <title>线性子空间笔记</title>
    <url>/2020/03/29/%E7%BA%BF%E6%80%A7%E5%AD%90%E7%A9%BA%E9%97%B4%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>&nbsp;<br><a id="more"></a></p>
<ul>
<li>关于线性子空间的证明，需证明<strong>集合$V_1$为线性空间$V$的非空子集合</strong>，然后证明空间$V_1$同时满足<strong>加法封闭性</strong>和<strong>数乘封闭性</strong></li>
<li>关于直和的证明： <br> <strong>若$V_1$、$V_2$为线性空间$V$的子空间(需证明)</strong>，则如下4种表述等价：<ul>
<li>$V_1+V_2$成为直和$V_1\oplus V_2$</li>
<li>$V_1\cap V_2 = \{0\}$</li>
<li>$dim\{V_1+V_2\} = dimV_1 + dimV_2$</li>
<li>$x_1,x_2,\cdots,x_s$为$V_1$的基，$y_1,y_2,\cdots,y_t$为$V_2$的基，则$x_1,x_2,\cdots,x_s,y_1,y_2,\cdots,y_t$为$V_1+V_2$的基</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Matrix Theory</category>
      </categories>
  </entry>
  <entry>
    <title>性能测量方法学习笔记</title>
    <url>/2020/03/21/%E6%80%A7%E8%83%BD%E6%B5%8B%E9%87%8F%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>性能测量方法本节主要讲四个代价函数</strong><br><a id="more"></a></p>
<h2 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h2><ul>
<li>$(R^{-1})^H = (R^H)^{-1}$</li>
</ul>
<h2 id="最小均方误差-MMSE"><a href="#最小均方误差-MMSE" class="headerlink" title="最小均方误差(MMSE)"></a>最小均方误差(MMSE)</h2><ul>
<li>参考信号$d_k$需与输入信号$x_k$间存在相关分量，否则，当$d_k$中与$x_k$中不存在相关分量时<script type="math/tex; mode=display">
E(|\varepsilon_k|^2) = E[(d_k - y_k)^*(d_k - y_k)] = E(|d_k|^2) + W^HRW</script>即参考向量和输入信号构成的互相关向量$P = E[d^*X] = 0$，此时为使$E(|\varepsilon_k|^2)$最小，权向量$W$应为零向量，此时自适应系统没有意义，不$work$</li>
</ul>
<h2 id="最大信噪比-MSN"><a href="#最大信噪比-MSN" class="headerlink" title="最大信噪比(MSN)"></a>最大信噪比(MSN)</h2><ul>
<li>需要注意的几个公式</li>
</ul>
<script type="math/tex; mode=display">S^{'}_k = AS_k</script><script type="math/tex; mode=display">N_k^{'} = AN_k</script><script type="math/tex; mode=display">W = A^TW^{'}</script><ul>
<li>应用条件是需已知$R_N$和$R_S$，即可以构建式子</li>
</ul>
<script type="math/tex; mode=display">
R_n^{-1}R_SW_{opt} = \lambda_{max}^{’}W_{opt}</script><p>从而可以求出最佳权向量$W_{opt}$</p>
<h2 id="最大似然-ML"><a href="#最大似然-ML" class="headerlink" title="最大似然(ML)"></a>最大似然(ML)</h2><ul>
<li>相干源 $&lt;=&gt;$ 统计相关</li>
<li>非相干源 $&lt;=&gt;$ 统计独立</li>
</ul>
<h2 id="最小方差-MV"><a href="#最小方差-MV" class="headerlink" title="最小方差(MV)"></a>最小方差(MV)</h2><ul>
<li><p>宽带模型与窄带模型</p>
<ul>
<li>孔径渡越时间$\tau$，脉冲压缩后信号的脉压宽度$T$，若<script type="math/tex; mode=display">
\tau \ll T \approx \frac{1}{B}</script>则为窄带模型，孔径渡越时间几乎可忽略</li>
<li>若$\tau$与$T$数量悬殊不大，则为宽带模型，可使用延时线对信号包络进行补偿</li>
</ul>
</li>
<li><p>利用拉格朗日乘子法将约束条件$W^T$<strong>$1$</strong>$= 1$和最小输出噪声方差的目标函数$W^HR_n^{‘}W$一起转化为了一个最小噪声方差性能函数，不过从几何上理解拉格朗日乘子法还是存在一定的困难。。。。</p>
<ul>
<li><a href="https://www.zhihu.com/question/38586401" target="_blank" rel="noopener">如何理解拉格朗日乘子法？</a></li>
</ul>
</li>
<li><p>最小方差准则是在一定的约束条件下，接收信号</p>
<script type="math/tex; mode=display">
y_k = W^TA(\theta)S(t) + W^TN(t)</script><p>被约束为</p>
<script type="math/tex; mode=display">
y_k = S(t) + W^TN(t)</script><p>即此时有$W^TA(\theta) = 1$，也即约束条件为$W^TA(\theta) = 1$，此时</p>
<script type="math/tex; mode=display">
var(y_k) = E[S(t)^*S(t)^T] + W^HR_nW</script><p>此时调整权值使得方差(即输出功率)最小，即得到了最优权$W_{opt}$，接收信号功率没法控制，等于是控制输出噪声功率最小，即总输出信号有最大的信噪比，也就是所谓的最小(噪声)方差准则</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Adaptive Signal Processing</category>
      </categories>
  </entry>
  <entry>
    <title>线性空间笔记</title>
    <url>/2020/03/20/%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>&nbsp;<br><a id="more"></a></p>
<h1 id="线性代数知识补充"><a href="#线性代数知识补充" class="headerlink" title="线性代数知识补充"></a>线性代数知识补充</h1><ul>
<li>齐次线性方程组以及非齐次线性方程组知识补充<ul>
<li><a href="https://blog.csdn.net/xiaotang_sama/article/details/101515550?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522158467969019726867822320%2522%252C%2522scm%2522%253A%252220140713.130056874..%2522%257D&amp;request_id=158467969019726867822320&amp;biz_id=0&amp;utm_source=distribute.pc_search_result.none-task" target="_blank" rel="noopener">线性代数05 齐次/非齐次线性方程组的具体解集</a></li>
<li><a href="https://blog.csdn.net/wwang196988/article/details/6766234" target="_blank" rel="noopener">求解非齐次线性方程组算法</a></li>
</ul>
</li>
</ul>
<h1 id="线性空间笔记"><a href="#线性空间笔记" class="headerlink" title="线性空间笔记"></a>线性空间笔记</h1><ul>
<li>线性空间的证明，需证明<strong>唯一性</strong>和<strong>封闭性</strong>，以及<strong>八条性质</strong>(加法四条、乘法四条)</li>
<li>线性空间总是相对数域而言的，相关证明记得关注数域</li>
<li>线性空间的维数与基的求解问题：<ul>
<li>欲求线性空间的基，需先求出该线性空间$V$的线性无关组，再证明该线性无关组元素个数最大即可 $&lt;=&gt;$ 即对于$\forall A\in V$，$A$均可由该线性无关组线性表示</li>
<li>线性空间$V$中最大线性无关组所含元素的个数称为$V$的维数，记作$dimV$，也即为基中所含元素的个数</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Matrix Theory</category>
      </categories>
  </entry>
  <entry>
    <title>阵列信号模型</title>
    <url>/2020/03/11/%E9%98%B5%E5%88%97%E4%BF%A1%E5%8F%B7%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>被阵列信号模型中的矩阵搞得晕头转向，矩阵中又嵌套向量，记录一下 <br><br><a id="more"></a><br>常见的阵列模型如下：<br><img src="https://gitee.com/gtjason1998/article_images/raw/master/article_images1.png" alt="阵列模型"></p>
<ul>
<li>$X$为全部阵元总的输出，$X = [X_1(t),X_2(t),\cdots,X_M(t)]^T$</li>
<li>$N(t)$为噪声，$N(t) = [n_1(t),n_2(t),\cdots,n_M(t)]^T$ </li>
<li>$A$为阵列导向向量构成的矩阵，$A = [A(\theta_1),A(\theta_2),\cdots,A(\theta_k)]$<ul>
<li>$A(\theta_i) = [1,e^{-j\frac{2\pi d}{\lambda}sin\theta_i},\cdots,e^{-j\frac{2\pi (M-1)d}{\lambda}sin\theta_i}]^T$</li>
</ul>
</li>
<li>$S(t)$为入射信号，$S(t) = [ S_1(t),S_2(t),\cdots,S_k(t)]^T$<ul>
<li>$S_i(t)=[S_{i1},S_{i2},\cdots,S_{im}]^T$<script type="math/tex; mode=display">
X = \underbrace{\underbrace{A}_{M\times k}\underbrace{S(t)}_{k\times m} + \underbrace{N(t)}_{M\times m}}_{M\times m} = \underbrace{\sum_{i=1}^{k}\underbrace{A(\theta_i)}_{M\times 1}\cdot \underbrace{S_i^T(t)}_{1\times m} + \underbrace{N(t)}_{M\times m}}_{M\times m}</script></li>
</ul>
</li>
<li>阵列导向矩阵$A$大小为$M\times k$，其中$M$表示阵元的个数(通道的个数)，$k$表示目标的数目(信源的数目)，$A(\theta_i)$大小为$M\times 1$，表示同一个信源在$M$个不同阵元(通道)下的相移</li>
<li>入射信号矩阵$S(t)$大小为$k\times m$，$k$表示目标的数目(信源的数目)，$m$表示$m$次采样，即快拍数为$m$，$S_i^T(t)$大小为$1\times m$，表示对同一个信源采样$m$次</li>
<li>$N(t)$为噪声矩阵，大小为$M\times m$，表示$M$个阵元(通道)在$m$次采样情况下形成的噪声矩阵</li>
</ul>
]]></content>
      <categories>
        <category>Adaptive Signal Processing</category>
      </categories>
  </entry>
  <entry>
    <title>信号矩阵理论学习笔记</title>
    <url>/2020/03/09/%E4%BF%A1%E5%8F%B7%E7%9F%A9%E9%98%B5%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>&nbsp;<br><a id="more"></a></p>
<h1 id="1-线性代数知识补充"><a href="#1-线性代数知识补充" class="headerlink" title="1. 线性代数知识补充"></a>1. 线性代数知识补充</h1><ul>
<li>$rank(AB) = min\{rank(A),rank(B)\}$</li>
<li>$(A^{-1})^T=(A^T)^{-1}$</li>
<li>$Tr(AB) = Tr(BA)$</li>
<li>$(AB)^T = B^TA^T$ </li>
<li>$(AB)^* = A^*B^*$<blockquote>
<p>转置前后矩阵位置交换<br>共轭前后矩阵位置不变</p>
</blockquote>
</li>
<li>矩阵可逆 $&lt;=&gt;$ 矩阵行列式不等于0 $&lt;=&gt;$ 矩阵满秩</li>
<li>矩阵特征值的个数等于其阶数，非零特征值的个数等于矩阵的秩 <br><br>$Q^{-1}RQ=\Lambda$，因为$Q$矩阵可逆，所以$Q$矩阵满秩，所以<br>$rank(Q^{-1}RQ) = min\{rank(Q^{-1},rank(R),rank(Q)\}= rank(R)= rank(\Lambda)$<br><br> 根据等式后两项，有矩阵的秩等于非零特征值的个数</li>
</ul>
<h1 id="2-输入信号相关矩阵"><a href="#2-输入信号相关矩阵" class="headerlink" title="2. 输入信号相关矩阵"></a>2. 输入信号相关矩阵</h1><ul>
<li>$R = E[X^*X^T]$ 其中$R$为$Hermite$阵，即$R^H = R$</li>
<li><p>$\omega^H R \omega$ &nbsp;$&lt;=&gt;$ &nbsp;输出信号功率 <br><br>因为自适应组合器信号输出(见课本公式(2.3))</p>
<script type="math/tex; mode=display">y(t)=q_n^TX = X^Tq_n</script><p>所以输出功率</p>
<script type="math/tex; mode=display">E[|y(t)|^2]=E[y^*(t)y(t)]=E[q_n^HX^*X^Tq_n] = q_n^HE[X^*X^T]q_n=q_n^HRq_n</script><p>其中$\omega$为信号线性组合器模型中的权向量，$R$为信号相关矩阵 <br><br>因为输出功率恒大于等于0且为实数，同时由于$Rq_n=\lambda_nq_n$，两边同乘$q_n^H$有</p>
<script type="math/tex; mode=display">
q_n^HRq_n=\lambda_nq_n^Hq_n</script><p>由于$q_n^Hq_n$为非零特征向量的内积，故$q_n^Hq_n$恒大于0，所以$\lambda_n$均为大于或等于0的正实数，即$\lambda_n \geq 0$，所以信号相关矩阵$R$为正定或半正定矩阵，详见<a href="https://baike.baidu.com/item/正定矩阵/11030459?fr=aladdin" target="_blank" rel="noopener">正定矩阵充要条件第4条</a></p>
</li>
<li><p>$R$可分解为(证明见课件)</p>
<script type="math/tex; mode=display">R=Q\Lambda Q^H \tag{1}</script><p>将等式(1)拆解开，还可表示为</p>
<script type="math/tex; mode=display">
R = \sum\lambda_iq_iq_i^H</script><p>&emsp;其中$\lambda_i$为信号相关矩阵的特征值，$q_i$为特征值$\lambda_i$对应的特征向量 <br><br>&emsp;因为<u><strong>特征向量矩阵$Q$内的所有特征向量是相互正交并各自归一化的，且不同特征值对应的特征向量相互正交</strong></u>(证明过程见课件)，即$Q$矩阵与$Q$矩阵自己的内积中非对角元素均为0，所以有$Q^HQ = I$,$I$为单位矩阵,所以有</p>
<script type="math/tex; mode=display">Q^{-1} = Q^H \tag{2}</script><p>&emsp;等式(2)和等式(1)联合，有</p>
<script type="math/tex; mode=display">R = Q\Lambda Q^H = Q\Lambda Q^{-1} \tag{3}</script></li>
<li>矩阵$R$的特征值之和为输入信号的功率 <br><br>因为$Tr(\Lambda) = Tr(R) = E[x_0^*x_0] + E[x_1^*x_1] + \cdots + E[x_L^*x_L]$(证明见课件)，其中等号最后一项即为各通道的输入功率之和</li>
</ul>
<h1 id="3-信号子空间和噪声子空间"><a href="#3-信号子空间和噪声子空间" class="headerlink" title="3. 信号子空间和噪声子空间"></a>3. 信号子空间和噪声子空间</h1><ul>
<li>信号子空间$U_s$与噪声子空间$U_n$正交 <br><script type="math/tex; mode=display">U_s \overset{\Delta}{=} span[q_0,q_1,\cdots,q_{r-1}]</script><script type="math/tex; mode=display">U_n \overset{\Delta}{=} span[q_r,q_{r+1},\cdots,q_{L}]</script>&emsp;&emsp;假设$S = \sum_{i=0}^{r-1}\alpha_iq_i$，即$S$可由信号子空间$U_s$张成的基向量线性表示，$N = \sum_{i=r}^{L}\alpha_iq_i$，即$N$可由噪声子空间$U_n$张成的基向量线性表示，因为信号相关矩阵$R$不同特征值对应的特征向量相互正交(证明见课件)，故有<script type="math/tex; mode=display">
S^H\cdot N=0</script>即信号子空间$U_s$与噪声子空间$U_n$正交</li>
</ul>
<h2 id="3-1-子空间分解算法应用"><a href="#3-1-子空间分解算法应用" class="headerlink" title="3.1. 子空间分解算法应用"></a>3.1. 子空间分解算法应用</h2><p>&emsp;信号子空间和噪声子空间的应用：<a href="https://blog.csdn.net/zhangziju/article/details/100730081" target="_blank" rel="noopener">MUSIC(Multiple Signal Classification)</a> <br><br>&emsp;其中:</p>
<ul>
<li>阵列导向向量$A(\theta)$是由信号子空间张成的基向量组成的</li>
<li>因为<script type="math/tex; mode=display">
S_{music} = \frac{1}{A(\theta_i)^HP_NA(\theta_i)}</script>&emsp;&emsp;当且仅当$\theta_i$为信源方向时，分母中的$A(\theta_i)$可由信号子空间张成的基向量线性表示，同时由于$P_N$可由噪声子空间线性表示，利用信号子空间和噪声子空间的正交性，所以此时分母的理论计算值为0，但由于噪声的存在，此时分母为一个很小的值，故$S_{music}(\theta_i)$计算结果为一尖峰值，此时对$music$谱($S_{music}-\theta$)进行谱峰搜索即可搜寻出目标的位置</li>
</ul>
]]></content>
      <categories>
        <category>Adaptive Signal Processing</category>
      </categories>
  </entry>
  <entry>
    <title>FMCW雷达距离多普勒(RDM)处理方法中距离分辨率和速度分辨率的推导</title>
    <url>/2020/02/12/FMCW%E9%9B%B7%E8%BE%BE%E8%B7%9D%E7%A6%BB%E5%A4%9A%E6%99%AE%E5%8B%92-RDM-%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E4%B8%AD%E8%B7%9D%E7%A6%BB%E5%88%86%E8%BE%A8%E7%8E%87%E5%92%8C%E9%80%9F%E5%BA%A6%E5%88%86%E8%BE%A8%E7%8E%87%E7%9A%84%E6%8E%A8%E5%AF%BC/</url>
    <content><![CDATA[<h1 id="1-距离多普勒-Range-Dopple-Matrix-处理方法"><a href="#1-距离多普勒-Range-Dopple-Matrix-处理方法" class="headerlink" title="1. 距离多普勒(Range-Dopple Matrix)处理方法"></a>1. 距离多普勒(Range-Dopple Matrix)处理方法</h1><p>&emsp;&emsp;众所周知，距离多普勒处理方法(Range-Dopple Matrix，简称RDM)是FMCW雷达进行多目标信息提取的有效手段，通过对雷达发送的多个周期的Chirp序列以及回波信息进行快时间维度和慢时间维度的处理，即可得到距离多普勒热力图，进而可以提取多目标的距离和速度信息。<br><a id="more"></a><br><img src="https://img-blog.csdnimg.cn/20200212132950250.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="FMCW Multi-Chirp"><br>在FMCW的差拍信号中，我们知道，差拍信号的频率为</p>
<script type="math/tex; mode=display">f_{movingBeat} = f_{staticBeat} \pm f_d = \frac{2f_cR}{Ct_c} \pm \frac{2fv}{C} \tag 1</script><p>其中$f_{movingBeat}$和$f_{staticBeat}$分别为目标运动和静止状态下差拍信号的频率，$f_d$为多普勒频率，$f_c$为扫频带宽，$R$为目标距离，$C$为光速，$t_c$为扫频周期，$f$为Chirp信号中心频率，$v$为目标速度。</p>
<h2 id="1-1-快时间维度处理-Range-FFT"><a href="#1-1-快时间维度处理-Range-FFT" class="headerlink" title="1.1. 快时间维度处理(Range-FFT)"></a>1.1. 快时间维度处理(Range-FFT)</h2><p>&emsp;&emsp;快时间维度即单个周期的Chirp序列扫频周期时间很短，短到几乎可以将多普勒频率带来的影响忽略不计($t_c$↓，公式(1)中$f_{staticBeat}$项占了主要的位置)，认为此时通过RDM热力图提取到的动目标在距离维度上的动目标差频$f_{movingBeat}$与静目标差频$f_{staticBeat}$近似相等，即</p>
<script type="math/tex; mode=display">f_{movingBeat} \approx f_{staticBeat} =  \frac{2f_cR}{Ct_c} \tag 2</script><p>那么通过快时间维度的每一帧数据，提取频谱峰值对应的横坐标频率，即可对目标的距离进行求解；即</p>
<script type="math/tex; mode=display">R = \frac{Ct_c}{2f_c}\cdot f_{staticBeat} \tag 3</script><p>快时间维处理示意图如下<br><img src="https://img-blog.csdnimg.cn/20200212133123832.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="Range-FFT"></p>
<h2 id="1-2-慢时间维度处理-Doppler-FFT"><a href="#1-2-慢时间维度处理-Doppler-FFT" class="headerlink" title="1.2. 慢时间维度处理(Doppler-FFT)"></a>1.2. 慢时间维度处理(Doppler-FFT)</h2><p>&emsp;&emsp;因为我们知道，在快时间维的处理中，认为速度带来的影响忽略不计，通过对多个Chirp序列进行多帧数据的堆积，此时在第二个维度上(即慢时间维度上，多帧数据对应的同一距离单元上)速度带来的频率影响就不可忽略，此时慢时间维度上求得的频率即为多普勒频率，即</p>
<script type="math/tex; mode=display">f_d = \frac{2fv}{C} \tag 4</script><p>所以有</p>
<script type="math/tex; mode=display">v = \frac{f_dC}{2f} \tag 5</script><p>慢时间维处理示意图如下<br><img src="https://img-blog.csdnimg.cn/20200212134519777.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="Doppler-FFT"><br>慢时间维度的处理是经过多个Chirp序列积累后对<strong>同一距离单元</strong>进行FFT的结果，故称为慢时间维度，</p>
<blockquote>
<p>为什么是同一距离单元？<br>因为Range-FFT中同一个横坐标对应相同的$f_{movingBeat}$，快时间维度下$f_{movingBeat}$约等于$f_{staticBeat}$，由公式(2)和公式(3)可知，对应同一距离单元</p>
</blockquote>
<p>快时间维度和慢时间维度处理总览<br><img src="https://img-blog.csdnimg.cn/20200212123652486.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="两个维度总览"><br>经过处理后可得到如下的距离多普勒热力图(Range-Dopple Heat Map)<br><img src="https://img-blog.csdnimg.cn/2020021213115734.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="Range-Dopple Heat Map"></p>
<h1 id="2-RDM中距离分辨率和速度分辨率推导方法"><a href="#2-RDM中距离分辨率和速度分辨率推导方法" class="headerlink" title="2. RDM中距离分辨率和速度分辨率推导方法"></a>2. RDM中距离分辨率和速度分辨率推导方法</h1><p>&emsp;&emsp;网上关于RDM方法中距离分辨率和速度分辨率推导的资料实在太少，几乎都是两个长得不太好看公式直接糊你脸上，我的感受就是<del>老人、地铁、看手机.jpg</del>(此处省略表情包)，于是决定记录下推导过程，正所谓难者不会，会者不难。<br><br>首先回顾下数字信号处理中第K个采样点的频率$f_k$与采样频率$f_s$间的关系，我们知道，第K个采样点的角频率服从如下关系</p>
<script type="math/tex; mode=display">\omega_k = \frac{k}{N_s}\cdot2\pi = \Omega\cdot T_s = 2 \pi f_k\cdot \frac{1}{f_s}</script><p>&emsp;其中$N_s$为采样点数，$\Omega$为模拟角频率，$T_s$为采样频率，我们取出等式中的第二项和第四项，有</p>
<script type="math/tex; mode=display">\frac{k}{N_s}\cdot2\pi =2 \pi f_k\cdot \frac{1}{f_s}</script><p>&emsp;可得第K个采样点的频率$f_k$与采样频率$f_s$间的关系为</p>
<script type="math/tex; mode=display">f_k = k\cdot \frac{f_s}{N_s} \tag 6</script><p>&emsp;到此就可以正式展开距离分辨率和速度分辨率的推导方法了，上一部分我们说到快时间维度的Range-FFT和慢时间维度的Doppler-FFT，有两个结论性的公式</p>
<script type="math/tex; mode=display">f_{movingBeat} \approx f_{staticBeat} =  \frac{2f_cR}{Ct_c} \tag 7</script><script type="math/tex; mode=display">f_d = \frac{2fv}{C}  \tag 8</script><p>&emsp;假设上一部分中距离多普勒热力图中，$n_1$为Range-FFT(快时间维度)中目标对应的坐标序列号，$n_2$为Doppler-FFT(慢时间维度)中同一目标对应的坐标序列号，则依照公式(6)可得</p>
<script type="math/tex; mode=display">f_{movingBeat} = \frac{n_1}{N_s} \cdot f_s \tag 9</script><script type="math/tex; mode=display">f_d = \frac{n_2}{N_{Chirp}} \cdot \frac{1}{t_c} \tag {10}</script><p>&emsp;其中$N_{Chirp}$为慢时间维度处理中Chirp序列的积累个数；公式(9)类比公式(6)，比较好理解，公式(10)也是类比公式(6)，只不过此时<strong>在慢时间维度上</strong>采样总数是积累的Chirp序列的总数，采样频率是每一个Chirp序列扫频周期的倒数，即$\frac{1}{t_c}$<br>&emsp;由此以来，分别联立公式(7)和公式(9)，联立公式(8)和公式(10)，可得</p>
<script type="math/tex; mode=display">\frac{2f_cR}{Ct_c} = \frac{n_1}{N_s} \cdot f_s</script><script type="math/tex; mode=display">\frac{2fv}{C} = \frac{n_2}{N_{Chirp}} \cdot \frac{1}{t_c}</script><p>&emsp;可解得</p>
<script type="math/tex; mode=display">R = \frac{C}{2f_C}\cdot t_c\cdot \frac{n_1}{N_s}\cdot f_s \tag{11}</script><script type="math/tex; mode=display">v = \frac{C}{2f} \cdot \frac{n_2}{N_{Chirp}}\cdot \frac{1}{t_c}\tag{12}</script><p>&emsp;因为 </p>
<script type="math/tex; mode=display">t_c = N_s\cdot T_s = \frac{N_s}{f_s} \tag{13}</script><script type="math/tex; mode=display">t_{seq} = N_{Chirp}\cdot t_c\tag{14}</script><p>&emsp;将(13)代入(11)，将(14)代入(12)，可得</p>
<script type="math/tex; mode=display">R = \frac{C}{2f_c} \cdot n_1</script><script type="math/tex; mode=display">v = \frac{C}{2ft_{seq}} \cdot n_2</script><p>&emsp;此时，就得到了距离分辨率和速度分辨率，分别为</p>
<script type="math/tex; mode=display">R_{res} = \frac{C}{2f_c}</script><script type="math/tex; mode=display">v_{res} = \frac{C}{2fN_{Chirp}t_c} = \frac{C}{2ft_{seq}}</script><h1 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3. 参考资料"></a>3. 参考资料</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/31047473" target="_blank" rel="noopener">Automotive radar 信号处理 第2课 速度估计</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/77500626" target="_blank" rel="noopener">Radar测距及测速原理(2)——快速Chirp序列方法推导及实际应用</a></li>
<li><a href="https://mp.weixin.qq.com/s/3pmABLMsirzEXcIn3a2_Pw" target="_blank" rel="noopener">2D CFAR的原理，其实没那么的神奇</a></li>
</ul>
]]></content>
      <categories>
        <category>Radar</category>
      </categories>
  </entry>
  <entry>
    <title>树莓派踩坑日记——初始配置</title>
    <url>/2019/12/06/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0%E2%80%94%E2%80%94%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><strong><em>无显示器无键盘、仅有一根网线时初步配置树莓派</em></strong><br><a id="more"></a></p>
<h1 id="1-Raspbian系统安装"><a href="#1-Raspbian系统安装" class="headerlink" title="1. Raspbian系统安装"></a>1. Raspbian系统安装</h1><p>使用读卡器烧录Raspbian镜像，可以烧录已经开启SSH的镜像源，方便直接连接，未开启SSH的话，在boot分区建立一个名为ssh的文件(无后缀)，即可</p>
<h1 id="2-通过网线连接树莓派"><a href="#2-通过网线连接树莓派" class="headerlink" title="2. 通过网线连接树莓派"></a>2. 通过网线连接树莓派</h1><p>在控制面版——网络和Internet——网络连接界面设置网络共享，然后网线连接树莓派，进入<code>cmd终端</code>，输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arp -a</span><br></pre></td></tr></table></figure>
<p>查看分配的ip地址，使用命令连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh pi@ip_address</span><br></pre></td></tr></table></figure>
<h1 id="3-初始配置"><a href="#3-初始配置" class="headerlink" title="3. 初始配置"></a>3. 初始配置</h1><h2 id="3-1-wifi配置"><a href="#3-1-wifi配置" class="headerlink" title="3.1. wifi配置"></a>3.1. wifi配置</h2><p>打开<code>wifi</code>，修改wifi配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/wpa_supplicant/wpa_supplicant.conf</span><br></pre></td></tr></table></figure>
<p>改成如下格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line">country=CN</span><br><span class="line">network=&#123;</span><br><span class="line">        ssid=<span class="string">"MERCURY_930E"</span></span><br><span class="line">        psk=<span class="string">"606606606"</span></span><br><span class="line">        key_mgmt=WPA-PSK</span><br><span class="line">        priority=4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最好将手机热点设置为最高优先级，通过设置优先级，保证你的树莓派可以连上wifi，之后只需通过起到路由功能的设备即可查看树莓派ip，同理通过ssh连接。<br>还有就是，按照网上方法修改<code>/etc/dhcpcd.conf</code>路径下的文件，设置静态ip，可以保证树莓派可以访问，但存在无法访问网络的问题，可能是DNS未配置好所致。</p>
<h2 id="3-2-raspi-config"><a href="#3-2-raspi-config" class="headerlink" title="3.2. raspi-config"></a>3.2. raspi-config</h2><h3 id="3-2-1-更改密码"><a href="#3-2-1-更改密码" class="headerlink" title="3.2.1. 更改密码"></a>3.2.1. 更改密码</h3><p>选择第一项，按提示更改密码</p>
<h3 id="3-2-2-拓展文件系统"><a href="#3-2-2-拓展文件系统" class="headerlink" title="3.2.2. 拓展文件系统"></a>3.2.2. 拓展文件系统</h3><p>保证你的整张SD卡可以被你的Raspbian系统访问，通过如下命令可以查看区别</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>
<h3 id="3-2-3-更改分辨率"><a href="#3-2-3-更改分辨率" class="headerlink" title="3.2.3. 更改分辨率"></a>3.2.3. 更改分辨率</h3><p>一般来说，需要根据你的显示器更改分辨率，视情况而定</p>
<h2 id="3-3-更改镜像源"><a href="#3-3-更改镜像源" class="headerlink" title="3.3. 更改镜像源"></a>3.3. 更改镜像源</h2><p>修改<code>/etc/apt/sources.list</code>和<code>/etc/apt/sources.list.d/raspi.list</code>文件，更改方法网上搜索很多，更改镜像源，然后执行更新指令即可完成初步配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade</span><br></pre></td></tr></table></figure>
<h1 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h1><p>千万不要在操作文件系统/使用树莓派GPIO口时断电，可能会造成文件系统损坏，导致之后无法正常进入系统，也就导致不能通过wifi或者网线连接树莓派</p>
]]></content>
      <categories>
        <category>RaspberryPi</category>
      </categories>
  </entry>
  <entry>
    <title>Linux中的echo命令做文本写入及文本追加</title>
    <url>/2019/10/23/Linux%E4%B8%AD%E7%9A%84echo%E5%91%BD%E4%BB%A4%E5%81%9A%E6%96%87%E6%9C%AC%E5%86%99%E5%85%A5%E5%8F%8A%E6%96%87%E6%9C%AC%E8%BF%BD%E5%8A%A0/</url>
    <content><![CDATA[<p>Linux中的<code>echo</code>命令，使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> text &gt; text.txt</span><br></pre></td></tr></table></figure>
<p>可以将text文本重定向至text.txt中<br><a id="more"></a></p>
<p><img src="https://img-blog.csdnimg.cn/20191023171525303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="echo文本重定向"><br>但若是想要作一个文本追加，则需要使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> text &gt;&gt; text.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191023171857597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="echo文本追加"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Matplotlib绘图中文无法显示</title>
    <url>/2019/10/23/Matplotlib%E7%BB%98%E5%9B%BE%E4%B8%AD%E6%96%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><a id="more"></a>
<p>在使用Matplotlib绘图过程中，中文无法显示，如下</p>
<p><img src="https://img-blog.csdnimg.cn/20191023165735108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="中文无法显示"></p>
<ul>
<li>解决方法一</li>
</ul>
<p>只需要在程序中添加以下代码即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> mpl</span><br><span class="line">mpl.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'SimHei'</span>] <span class="comment"># 指定默认字体</span></span><br><span class="line">mpl.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span>  <span class="comment"># 解决保存图像是负号'-'显示为方块的问题</span></span><br></pre></td></tr></table></figure>
<p><strong>但若是使用的Linux系统</strong>,比如我使用的是deepin，则需要先去网上下载SimHei.ttf的字体文件，拷贝至以下目录下(user处应为对应用户名，具体情况具体分析)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/home/user/.<span class="built_in">local</span>/lib/python3.6/site-packages/matplotlib/mpl-data/fonts/ttf</span><br></pre></td></tr></table></figure>
<p>然后再删除掉以下这个名为matplotlib的目录即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/home/user/.cache/matplotlib</span><br></pre></td></tr></table></figure>
<ul>
<li>解决方法二</li>
</ul>
<p>比如此图是在设置title时，中文无法正常显示只需给<code>plt.title()</code>增加参数即可，即<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.title(<span class="string">'3D图'</span>,family = <span class="string">'SimHei'</span>)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>关于Python中可以使用的字体种类及相关属性，详见<blockquote>
<p><a href="https://blog.csdn.net/weixin_40161254/article/details/82858627" target="_blank" rel="noopener">matplotlib 修改字体属性(旋转，类型，粗细，颜色，大小)</a></p>
</blockquote>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20191023170033174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="中文正常显示"></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Python中的引用与浅拷贝</title>
    <url>/2019/10/23/Python%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h1 id="1-导语"><a href="#1-导语" class="headerlink" title="1. 导语"></a>1. 导语</h1><p>挺绕的知识点，自己边看别人的博客边整理自己遇到的问题，磕磕绊绊写下这篇博客<br><a id="more"></a></p>
<h1 id="2-浅谈变量、对象及引用间的关系"><a href="#2-浅谈变量、对象及引用间的关系" class="headerlink" title="2. 浅谈变量、对象及引用间的关系"></a>2. 浅谈变量、对象及引用间的关系</h1><p><img src="https://img-blog.csdnimg.cn/20191023110947950.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="变量、对象及引用间的关系"></p>
<ul>
<li>变量 ：变量可以看作是一个标签，它无类型，建立后存入系统变量表</li>
<li>引用 ：引用可以看作是一个特殊的”指针”，它存放着对象的地址</li>
<li>对象 ：对象是计算机分配的一块实际的内存，里边存放着相应的值<h1 id="3-引用-reference"><a href="#3-引用-reference" class="headerlink" title="3. 引用(reference)"></a>3. 引用(reference)</h1>在Python中，<strong>赋值语句</strong>，总是在 <strong>建立对象的引用</strong>(建立指针) 或是 <strong>修改变量的引用</strong>(修改指针)，通过引用可以查看相应的值在内存中的存放地址，Python中，通过内置函数id()来查看对象的存放地址，如<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">id(list1)	<span class="comment">#该语句可以查看list1列表在进程空间中的存放地址</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-1-可变对象与不可变对象的引用问题"><a href="#3-1-可变对象与不可变对象的引用问题" class="headerlink" title="3.1. 可变对象与不可变对象的引用问题"></a>3.1. 可变对象与不可变对象的引用问题</h2><p>Python中，对象可分为可变对象和不可变对象，首先讨论什么是可变对象，什么是不可变对象</p>
<ul>
<li>可变对象 ：如list、set、dict<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>]	<span class="comment">#可变对象，赋值语句在此处是在建立对象的引用</span></span><br><span class="line">list2 = list1			</span><br><span class="line">print(id(list1),id(list2))</span><br><span class="line">list1[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">print(list2)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20191023160728248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="可变对象"><br>list1与list2指向同一块内存，通过修改list1，可以发现list2也受到了影响</p>
<ul>
<li>不可变对象 ：如str、number、tuple</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">'123'</span>	<span class="comment">#不可变对象，赋值语句在此处是在建立对象的引用</span></span><br><span class="line">print(id(str1))</span><br><span class="line">str1 = <span class="string">'012'</span>	<span class="comment">#创建新对象，并修改该变量的引用</span></span><br><span class="line">print(id(str1))</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191023161006193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="不可变对象"><br>此处的赋值语句，是在先创建了一个新的str对象的基础上，在修改变量str1的引用</p>
<h1 id="4-浅拷贝-shallow-copy"><a href="#4-浅拷贝-shallow-copy" class="headerlink" title="4. 浅拷贝(shallow copy)"></a>4. 浅拷贝(shallow copy)</h1><p>在使用NumPy的ndarray对象时，可使用该对象的copy()方法实现浅拷贝(shallow copy)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">array = np.arange(<span class="number">5</span>)</span><br><span class="line">array_illusion = array</span><br><span class="line">array_copy = array.copy()</span><br><span class="line">print(id(array),id(array_illusion),id(array_copy))</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191023162826950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70#pic_center" alt="浅拷贝"><br>根据输出的内存地址可以得知，未使用copy()方法的赋值语句，只是给第1行建立的ndarray对象又建立了一个新的引用，并贴上array_illusion的“标签”，而使用copy()方法则是真正的建立了一个新的ndarray对象</p>
<h1 id="5-后记"><a href="#5-后记" class="headerlink" title="5. 后记"></a>5. 后记</h1><p>最近在完成学校的数值计算作业的时候，将Matlab的程序转为了Python的程序来实现，由于里边每一次的迭代都需要重新赋值，自己在编写的时候又忽略了Python赋值语句本质上是在操控引用，不像Matlab那样只需要空间预分配就行，进而导致怎么都算不出正确结果，查阅资料补了补知识，在Python赋值语句的后边加上了.copy()，便得到了正确的结果，所以决定写下这篇博客，作为一个学习笔记。本来还想一起把深拷贝的内容也写了，但考虑到自己掌握的也不是太好，同时也不在这篇文章的讨论范围内，就索性等有时间再写了&gt;_&lt;</p>
<h2 id="5-1-参考文章"><a href="#5-1-参考文章" class="headerlink" title="5.1. 参考文章"></a>5.1. 参考文章</h2><p><a href="https://blog.csdn.net/qq_40911298/article/details/100060756" target="_blank" rel="noopener">Python 赋值引用、浅拷贝、深拷贝详细解析</a><br><a href="https://my.oschina.net/leejun2005/blog/145911" target="_blank" rel="noopener">python基础（5）：深入理解 python 中的赋值、引用、拷贝、作用域</a><br><a href="https://blog.csdn.net/Invokar/article/details/89138684" target="_blank" rel="noopener">Python变量引用浅析</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Linux中的Bash操作符&amp;,&amp;&amp;,|,||及部分基本指令</title>
    <url>/2019/10/03/Linux%E4%B8%AD%E7%9A%84Bash%E6%93%8D%E4%BD%9C%E7%AC%A6-%E5%8F%8A%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="1-操作符-amp-amp-与"><a href="#1-操作符-amp-amp-与" class="headerlink" title="1. 操作符&amp;&amp;与||"></a>1. 操作符&amp;&amp;与||</h1><ul>
<li>&amp;&amp;表示当前一条命令执行成功时,执行后一条命令</li>
<li>||表示当前一条命令执行失败时,才执行后一条命令<a id="more"></a>
当前目录下的子目录如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191003000600742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70" alt="操作符&amp;&amp;与||]"><br>使用如下命令区分&amp;&amp;与||的不同之处<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> Documents/ &amp;&amp; <span class="built_in">echo</span> success    <span class="comment">#success</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> Doc/ &amp;&amp; <span class="built_in">echo</span> fail             <span class="comment">#fail</span></span><br><span class="line"><span class="built_in">cd</span> Doc/ || <span class="built_in">echo</span> success          <span class="comment">#success</span></span><br><span class="line"><span class="built_in">cd</span> Documents/ || <span class="built_in">echo</span> fail       <span class="comment">#fail</span></span><br></pre></td></tr></table></figure>
执行结果如下：<br><img src="https://img-blog.csdnimg.cn/20191003001614414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70" alt="操作符&amp;&amp;与||"><br>根据ls命令返回的结果可知，当前目录下存在名为Documents的子目录，不存在名为Doc的子目录，所以第二条指令可以进入Documents子目录并输出success；接着使用命令返回上一层目录，而当前目录下不存在名为Doc的子目录，所以第三条指令不会输出fail；||的解读方法以此类推。</li>
</ul>
<h1 id="2-操作符-amp-与"><a href="#2-操作符-amp-与" class="headerlink" title="2. 操作符&amp;与|"></a>2. 操作符&amp;与|</h1><ul>
<li>&amp;表示将任务置于后台运行</li>
<li>|表示将前一条命令的输出，用作后一条命令的输入<br>为了更好的解读操作符&amp;与|，首先编写了一个如下的C语言程序</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"usage: CPU &lt;string&gt;\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *str = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usleep(<span class="number">1000000</span>);   <span class="comment">//delay 1S</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序在执行时，每隔1秒输出一次执行时的命令行参数；编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc cpu.c -o cpu.out</span><br></pre></td></tr></table></figure>
<p>通过如下命令来后台执行多个任务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./cpu.out A &amp; ./cpu.out B &amp; ./cpu.out C &amp;</span><br></pre></td></tr></table></figure>
<p>执行上述命令后，通过如下指令来查看运行情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -A | grep cpu.out</span><br></pre></td></tr></table></figure>
<p>上述指令中包含了管道符|，前一条指令的输出做后一条指令的输入，通过ps -A查看进程状态，输出信息做后一条字符串搜索指令grep的输入，进而实现查询cpu.out进程的运行情况，结果如下<br><img src="https://img-blog.csdnimg.cn/20191003004439729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70" alt="操作符&amp;与|"><br><img src="https://img-blog.csdnimg.cn/20191003004453373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70" alt="操作符&amp;与|"><br>可以看见已经查询到了后台运行的三个cpu.out进程，接着使用kill  PID指令关闭这三个进程<br><img src="https://img-blog.csdnimg.cn/20191003004658967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70" alt="操作符&amp;与|"><br><img src="https://img-blog.csdnimg.cn/2019100300471039.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjQ4NDcx,size_16,color_FFFFFF,t_70" alt="操作符&amp;与|"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/10/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><a id="more"></a>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h3 id="Clean-the-local-static-files"><a href="#Clean-the-local-static-files" class="headerlink" title="Clean the local static files"></a>Clean the local static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/commands" target="_blank" rel="noopener">Commands</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
</search>
